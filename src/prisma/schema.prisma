generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "postgresql"
  url          = env("DATABASE_URL")
  directUrl    = env("DIRECT_URL")
  relationMode = "prisma"
}

model User {
  id              String           @id @default(cuid())
  email           String           @unique
  name            String?
  googleId        String           @unique
  refreshToken    String
  accessToken     String?
  tokenExpiry     DateTime?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  events          CalendarEvent[]
  webhookChannels WebhookChannel[]

  @@map("users")
}

model CalendarEvent {
  id                  String    @id @default(cuid())
  googleEventId       String    @unique
  userId              String
  calendarId          String
  title               String
  description         String?
  startTime           DateTime
  endTime             DateTime
  location            String?
  attendees           Json?
  isAiEvent           Boolean   @default(false)
  parsedIntent        String?
  parsedAction        String?
  parsedAmount        Json?
  parsedRecipient     Json?
  parsedFromToken     String?
  parsedToToken       String?
  parsedProtocol      String?
  parsedChain         String?
  parsedParticipants  Json?
  parsedPool          String?
  parsedPlatform      String?
  parsedConfidence    Float?
  parsedScheduledTime DateTime?
  parsedCommandRaw    Json?
  isExecuted          Boolean   @default(false)
  executionHash       String?
  executedAt          DateTime?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("calendar_events")
}

model WebhookChannel {
  id         String   @id @default(cuid())
  userId     String
  channelId  String   @unique
  resourceId String
  expiration DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("webhook_channels")
}

model Wallet {
  id            String        @id @default(cuid())
  userId        String        @unique
  privyWallet   String
  privyWalletId String?
  agentWalletId String        @unique
  agentAddress  String
  status        WalletStatus  @default(ACTIVE)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  walletChains  WalletChain[]

  @@map("wallets")
}

model WalletChain {
  id           String       @id @default(cuid())
  walletId     String
  chainId      Int
  smartAccount String?
  status       WalletStatus @default(ACTIVE)
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  wallet       Wallet       @relation(fields: [walletId], references: [id], onDelete: Cascade)

  @@unique([walletId, chainId])
  @@map("wallet_chains")
}

model AgentWalletKey {
  id                  String   @id @default(cuid())
  walletId            String   @unique
  encryptedPrivateKey String
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@map("agent_wallet_keys")
}

enum WalletStatus {
  ACTIVE
  REVOKED
  PENDING
}
