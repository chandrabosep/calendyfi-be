generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "postgresql"
  url          = env("DATABASE_URL")
  directUrl    = env("DIRECT_URL")
  relationMode = "prisma"
}

model User {
  id                    String                 @id @default(cuid())
  email                 String                 @unique
  name                  String?
  googleId              String                 @unique
  refreshToken          String
  accessToken           String?
  tokenExpiry           DateTime?
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  events                CalendarEvent[]
  webhookChannels       WebhookChannel[]
  flowScheduledPayments FlowScheduledPayment[]

  @@map("users")
}

model CalendarEvent {
  id                  String    @id @default(cuid())
  googleEventId       String    @unique
  userId              String
  calendarId          String
  title               String
  description         String?
  startTime           DateTime
  endTime             DateTime
  location            String?
  attendees           Json?
  isAiEvent           Boolean   @default(false)
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  parsedAction        String?
  parsedAmount        Json?
  parsedChain         String?
  parsedCommandRaw    Json?
  parsedConfidence    Float?
  parsedFromToken     String?
  parsedIntent        String?
  parsedParticipants  Json?
  parsedPlatform      String?
  parsedPool          String?
  parsedProtocol      String?
  parsedRecipient     Json?
  parsedScheduledTime DateTime?
  parsedToToken       String?
  executedAt          DateTime?
  executionHash       String?
  isExecuted          Boolean   @default(false)
  flowCadenceTxId     String?
  flowEvmTxHash       String?
  flowScheduleId      String?
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("calendar_events")
}

model WebhookChannel {
  id         String   @id @default(cuid())
  userId     String
  channelId  String   @unique
  resourceId String
  expiration DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("webhook_channels")
}

model Wallet {
  id            String        @id @default(cuid())
  userId        String        @unique
  privyWallet   String
  privyWalletId String?
  agentWalletId String        @unique
  agentAddress  String
  status        WalletStatus  @default(ACTIVE)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  walletChains  WalletChain[]

  @@map("wallets")
}

model WalletChain {
  id           String       @id @default(cuid())
  walletId     String
  chainId      Int
  smartAccount String?
  status       WalletStatus @default(ACTIVE)
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  wallet       Wallet       @relation(fields: [walletId], references: [id], onDelete: Cascade)

  @@unique([walletId, chainId])
  @@map("wallet_chains")
}

model AgentWalletKey {
  id                  String   @id @default(cuid())
  walletId            String   @unique
  encryptedPrivateKey String
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@map("agent_wallet_keys")
}

model FlowScheduledPayment {
  id            String    @id @default(cuid())
  scheduleId    String    @unique
  userId        String
  recipient     String
  amount        String
  delaySeconds  Int
  scheduledTime DateTime
  method        String    @default("evm")
  evmTxHash     String?
  cadenceTxId   String?
  eventId       String?
  description   String?
  executed      Boolean   @default(false)
  executedAt    DateTime?
  executionTxId String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("flow_scheduled_payments")
}

model PriceTrigger {
  id                String    @id @default(cuid())
  userId            String
  triggerType       String // "above", "below", "equals"
  targetPrice       Float
  currentPrice      Float?
  fromToken         String
  toToken           String
  amount            String
  chainId           Int
  isActive          Boolean   @default(true)
  slippageTolerance Float?    @default(2.0)
  gasLimit          String?
  description       String?
  calendarEventId   String?
  status            String    @default("pending") // "pending", "triggered", "executed", "failed", "cancelled"
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  triggeredAt       DateTime?
  executedAt        DateTime?

  @@map("price_triggers")
}

model PriceAlert {
  id                 String   @id @default(cuid())
  userId             String
  token              String
  chainId            Int
  triggerType        String // "above", "below"
  targetPrice        Float
  isActive           Boolean  @default(true)
  notificationMethod String   @default("email") // "email", "calendar", "both"
  message            String?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@map("price_alerts")
}

enum WalletStatus {
  ACTIVE
  REVOKED
  PENDING
}
